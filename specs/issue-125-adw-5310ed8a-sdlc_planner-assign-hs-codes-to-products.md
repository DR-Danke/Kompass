# Feature: Post-Import HS Code Assignment to Products

## Metadata
issue_number: `125`
adw_id: `5310ed8a`
issue_json: ``

## Feature Description
Create a standalone CLI script that assigns HS (Harmonized System) codes to imported products based on their category, using a hardcoded category-to-HS-code mapping. The script loads `seed_mappings.json` (generated by SCD-002) to resolve category UUIDs and HS code UUIDs, builds a reverse map from `{category_uuid: hs_code_uuid}`, queries all products missing HS codes, and assigns them. For products in unmapped categories (e.g., "ONE STOP SHOP") or without categories, an optional `--use-ai` flag enables AI-based HS code suggestion via the existing `extraction_service.suggest_hs_code()` method with rate limiting. The script supports `--dry-run`, `--verbose`, and `--use-ai` CLI flags, prints a formatted summary table, and writes detailed results to `scripts/output/hs_assignment_results.json`.

This is the final issue (SCD-005) in the "Load Supplier Catalog Data" feature set, completing the data pipeline: seed reference data → import products → assign HS codes.

## User Story
As a Kompass system administrator
I want to run a script that assigns HS codes to all imported products based on their category
So that the pricing engine can calculate tariffs for automated COP quotations

## Problem Statement
After SCD-003 imported hundreds of products from supplier catalogs, products have category assignments but no HS code assignments. The pricing engine requires HS codes to calculate tariffs (`duty_rate` from the `hs_codes` table) as part of the COP quotation formula. Without HS codes, quotation automation cannot function. Manual assignment of HS codes to hundreds of products is impractical.

## Solution Statement
Create `apps/Server/scripts/assign_hs_codes.py` — a standalone CLI script that:
1. Loads `seed_mappings.json` to get category path → UUID and HS code → UUID mappings
2. Uses the hardcoded `CATEGORY_HS_MAP` to build a `{category_uuid: hs_code_uuid}` reverse map
3. Queries all products with `category_id IS NOT NULL AND hs_code_id IS NULL` using raw SQL (consistent with repository pattern for bulk operations)
4. Assigns HS codes by matching each product's `category_id` to the reverse map
5. Optionally processes unmatched/uncategorized products via AI suggestion (`--use-ai`)
6. Updates products using `product_repository.update(product_id, hs_code_id=uuid)`
7. Prints a summary table and writes detailed results to JSON

## Relevant Files
Use these files to implement the feature:

### Existing Files
- `apps/Server/scripts/seed_all.py` — Reference for script patterns: sys.path setup, output directory, JSON writing. Shows how `seed_mappings.json` is structured with `categories`, `suppliers`, and `hs_codes` sections.
- `apps/Server/scripts/seed_hs_codes.py` — Reference for HS code data: 15 hardcoded codes with their duty rates. Uses `hs_code_repository.get_by_code()` and `hs_code_repository.create()`. Shows the seeded HS codes that will be mapped to categories.
- `apps/Server/scripts/seed_categories.py` — Reference for `CATEGORY_TREE` structure (11 root categories with subcategories). Category paths use format `ROOT/Child` (e.g., `BAÑOS/Griferías`). Shows how category UUIDs are keyed in `seed_mappings.json`.
- `apps/Server/scripts/import_products.py` — Reference for script patterns: argparse, `load_seed_mappings()`, output JSON, summary table, verbose flag. Products were imported with `category_id` but no `hs_code_id`.
- `apps/Server/scripts/__init__.py` — Exists (empty), enables `python -m scripts.assign_hs_codes`
- `apps/Server/app/repository/kompass_repository.py` — `product_repository` singleton at line 5161. `ProductRepository.update()` at line 2752 accepts `hs_code_id: Optional[UUID]` parameter. `hs_code_repository` singleton at line 5159. `HSCodeRepository.get_by_code()` at line 1091 for looking up HS codes.
- `apps/Server/app/services/extraction_service.py` — `extraction_service` singleton at line 957. `suggest_hs_code(product_description: str) -> HsCodeSuggestion` at line 783. Returns `HsCodeSuggestion` with `code`, `description`, `confidence_score`, `reasoning`. Falls back to `9999.99.99` if AI unavailable.
- `apps/Server/app/models/extraction_dto.py` — `HsCodeSuggestion` DTO used by `suggest_hs_code()` return type.
- `apps/Server/database/schema.sql` — `products` table (line 203): `hs_code_id UUID REFERENCES hs_codes(id) ON DELETE SET NULL`. `hs_codes` table (line 94): `code VARCHAR(20) NOT NULL UNIQUE`, `duty_rate DECIMAL(5,2)`.
- `.gitignore` — Already includes `apps/Server/scripts/output/` pattern (line 94), so `hs_assignment_results.json` is already gitignored.

### New Files
- `apps/Server/scripts/assign_hs_codes.py` — The HS code assignment script (main deliverable)

## Implementation Plan
### Phase 1: Foundation
- Set up the script structure following existing patterns from `import_products.py` and `seed_all.py` (sys.path setup, argparse, output directory)
- Define the `CATEGORY_HS_MAP` dictionary mapping category paths to HS code strings
- Implement `load_seed_mappings()` function (reuse pattern from `import_products.py`)
- Build the `category_uuid → hs_code_uuid` reverse map by cross-referencing `CATEGORY_HS_MAP` with the `categories` and `hs_codes` sections of `seed_mappings.json`

### Phase 2: Core Implementation
- Query products needing HS codes using `product_repository` — products with `category_id` set but `hs_code_id` not set
- For each product, look up the `hs_code_uuid` from the reverse map using `category_id`
- Update matched products via `product_repository.update(product_id, hs_code_id=hs_code_uuid)`
- Track unmatched products (category not in map, e.g., ONE STOP SHOP, or parent-level categories like BAÑOS, MOBILIARIO, PISOS - GUARDAESCOBAS, REVESTIMIENTOS)
- Implement AI suggestion path (gated by `--use-ai`): call `extraction_service.suggest_hs_code()` with rate limiting (1 per second), match returned code against seeded HS codes
- Handle products with no category (also via AI if `--use-ai`)

### Phase 3: Integration
- Implement `--dry-run` mode: show what would be assigned without database writes
- Implement `--verbose` mode: print each individual assignment
- Print formatted summary table with accurate counts
- Write detailed results to `scripts/output/hs_assignment_results.json`
- Ensure idempotency: products that already have `hs_code_id` are skipped entirely

## Step by Step Tasks

### Step 1: Read reference files
- Read `apps/Server/scripts/import_products.py` to understand existing script patterns (argparse, seed mappings loading, output JSON, summary table)
- Read `apps/Server/scripts/seed_hs_codes.py` to understand seeded HS codes
- Read `apps/Server/scripts/seed_categories.py` to understand category tree and path format
- Read `apps/Server/app/repository/kompass_repository.py` lines 2752-2850 to understand `ProductRepository.update()` method signature
- Read `apps/Server/app/services/extraction_service.py` lines 783-856 to understand `suggest_hs_code()` method

### Step 2: Create `apps/Server/scripts/assign_hs_codes.py`
- Create the script with the following structure:

**Module docstring and imports:**
```python
#!/usr/bin/env python3
"""Assign HS codes to imported products based on category-to-HS-code mapping.

Usage:
    cd apps/Server
    python -m scripts.assign_hs_codes              # Category mapping only
    python -m scripts.assign_hs_codes --use-ai      # Include AI suggestions
    python -m scripts.assign_hs_codes --dry-run     # Preview only
    python -m scripts.assign_hs_codes --verbose     # Detailed output
"""

import argparse
import json
import os
import sys
import time
from typing import Any, Optional
from uuid import UUID

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from app.repository.kompass_repository import product_repository, hs_code_repository
from app.services.extraction_service import extraction_service
```

**CATEGORY_HS_MAP constant** — Hardcoded mapping from the issue:
```python
CATEGORY_HS_MAP = {
    "BAÑOS/Griferías": "7324.90",
    "BAÑOS/Lavamanos": "7324.10",
    "BAÑOS/Sanitarios y Muebles de Baño": "6910.10",
    "DECK - FACHADAS": "4411.14",
    "DISPENSADORES": "8481.80",
    "DOTACIÓN DE COCINA": "7323.93",
    "ESPEJOS": "7013.49",
    "ILUMINACIÓN": "9405.10",
    "MOBILIARIO/Camas": "9403.60",
    "MOBILIARIO/Mesas de Noche": "9403.60",
    "MOBILIARIO/Mobiliario Restaurante": "9403.20",
    "MOBILIARIO/Mobiliario a Medida": "9401.61",
    "ONE STOP SHOP": None,  # Mixed category — needs manual or AI assignment
    "PISOS - GUARDAESCOBAS/SPC Floor": "3921.90",
    "PISOS - GUARDAESCOBAS/Guardaescobas": "3917.40",
    "REVESTIMIENTOS/Panel Exterior": "6907.21",
    "REVESTIMIENTOS/Panel Interior": "6907.21",
    "TARIMAS & EVENTOS": "7610.90",
}
```

**Output constants:**
```python
OUTPUT_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "output")
RESULTS_FILE = os.path.join(OUTPUT_DIR, "hs_assignment_results.json")
MAPPINGS_FILE = os.path.join(OUTPUT_DIR, "seed_mappings.json")
```

**`load_seed_mappings()` function** — Reuse pattern from `import_products.py`. Load and validate that `categories` and `hs_codes` sections exist.

**`build_category_hs_map(mappings)` function:**
- Iterate `CATEGORY_HS_MAP` entries
- For each entry where the HS code is not None:
  - Look up the category UUID from `mappings["categories"][category_path]`
  - Look up the HS code UUID from `mappings["hs_codes"][hs_code]`
  - If both exist, add `{category_uuid: hs_code_uuid}` to the reverse map
  - If category or HS code not found in mappings, print a warning
- Return the reverse map `{category_uuid_str: hs_code_uuid_str}`

**`get_products_without_hs_code()` function:**
- Use raw SQL via database connection (following repository pattern for bulk queries) to get all products where `hs_code_id IS NULL`
- Return list of dicts with `id`, `name`, `description`, `category_id`, `hs_code_id`
- This avoids paginated `get_all()` limitations

**`assign_by_category(products, reverse_map, args)` function:**
- For each product with a `category_id`:
  - Look up `category_id` in reverse_map
  - If found and not dry-run: call `product_repository.update(product_id, hs_code_id=UUID(hs_code_uuid))`
  - If found and dry-run: just log it
  - If not found: add to unmatched list
- Return counts and lists: `mapped_count`, `unmatched_products`

**`assign_by_ai(products, hs_code_map, args)` function:**
- Only called if `--use-ai` flag is set
- `hs_code_map` is `{hs_code_string: hs_code_uuid}` from seed mappings
- For each product:
  - Build description string from product name + description
  - Call `extraction_service.suggest_hs_code(description)`
  - If returned code matches a seeded HS code (truncate to 7 chars like `XXXX.XX` for matching): assign it
  - Rate limit: `time.sleep(1)` between AI calls
  - If dry-run: just log the suggestion
- Return `ai_assigned_count`

**`print_summary(results)` function** — Print formatted summary table as specified in issue.

**`write_results_json(results)` function** — Write detailed results to `hs_assignment_results.json`.

**`main()` function:**
- Parse CLI args: `--use-ai`, `--dry-run`, `--verbose`
- Load seed mappings
- Build reverse map
- Get all products without HS codes
- Split into: products with category, products without category
- Run category-based assignment
- If `--use-ai`: run AI assignment on unmatched + uncategorized products
- Print summary
- Write results JSON

### Step 3: Validate the script
- Run `cd apps/Server && python -c "from scripts.assign_hs_codes import CATEGORY_HS_MAP; print(len(CATEGORY_HS_MAP))"` to verify import works
- Run `cd apps/Server && python -m scripts.assign_hs_codes --dry-run` to verify the script runs without errors

### Step 4: Run validation commands
- Run all validation commands listed below to ensure zero regressions

## Testing Strategy
### Unit Tests
No unit tests are required for this script. It is a one-time operational script (like `import_products.py` and `seed_all.py`) that does not have unit tests in the existing codebase. The script will be validated through dry-run execution and the validation commands below.

### Edge Cases
- **Products already having hs_code_id**: Must be skipped entirely (idempotent behavior)
- **Category not in CATEGORY_HS_MAP**: e.g., parent categories like "BAÑOS", "MOBILIARIO", "PISOS - GUARDAESCOBAS", "REVESTIMIENTOS" that were used in some imports but don't have direct HS code mappings — these go to unmatched list
- **ONE STOP SHOP category**: Explicitly mapped to `None` — goes to unmatched list for AI processing
- **Products with no category_id**: Only processed via AI if `--use-ai` flag is set
- **AI returns unknown HS code**: If `suggest_hs_code()` returns a code not in seeded HS codes, skip assignment
- **AI returns fallback code (9999.99.99)**: Skip assignment, add to "still without HS code" list
- **AI service unavailable**: `suggest_hs_code()` already handles this with fallback, script just skips
- **Empty database (no products)**: Script prints "0 products to process" and exits cleanly
- **Missing seed_mappings.json**: Script prints error and exits with code 1
- **Dry-run mode**: No database writes, full reporting

## Acceptance Criteria
- [ ] `CATEGORY_HS_MAP` covers all 18 categories (17 with HS codes + ONE STOP SHOP with None)
- [ ] Products with categories get correct HS codes assigned via the reverse map
- [ ] Products already having `hs_code_id` are skipped (idempotent)
- [ ] "ONE STOP SHOP" and unmapped parent categories are handled gracefully (added to unmatched list)
- [ ] AI suggestion works when `--use-ai` flag is set with 1-second rate limiting
- [ ] AI suggestions are matched against seeded HS codes only (no arbitrary codes assigned)
- [ ] `--dry-run` flag shows all changes without database writes
- [ ] `--verbose` flag prints each individual assignment
- [ ] Summary table is printed with accurate counts matching the format in the issue
- [ ] `hs_assignment_results.json` is written to `scripts/output/` with full details
- [ ] Script runs via `cd apps/Server && python -m scripts.assign_hs_codes`
- [ ] Script exits cleanly if `seed_mappings.json` is missing

## Validation Commands
Execute every command to validate the feature works correctly with zero regressions.

- `cd /mnt/c/Users/user/danke_apps/Kompass/trees/5310ed8a/apps/Server && python -c "import sys; sys.path.insert(0, '.'); from scripts.assign_hs_codes import CATEGORY_HS_MAP; print(f'CATEGORY_HS_MAP has {len(CATEGORY_HS_MAP)} entries')"` — Verify script imports correctly
- `cd /mnt/c/Users/user/danke_apps/Kompass/trees/5310ed8a/apps/Server && python -m scripts.assign_hs_codes --dry-run` — Run script in dry-run mode to verify it works end-to-end without database changes
- `cd /mnt/c/Users/user/danke_apps/Kompass/trees/5310ed8a/apps/Server && .venv/bin/pytest tests/ -v --tb=short` — Run Server tests to validate zero regressions
- `cd /mnt/c/Users/user/danke_apps/Kompass/trees/5310ed8a/apps/Server && .venv/bin/ruff check .` — Run linter to validate code quality

## Notes
- This is the final issue (SCD-005) in the "Load Supplier Catalog Data" feature set (Phase 3 of 3)
- The script follows the same patterns as `import_products.py` and `seed_all.py` — no new dependencies required
- Some products may have parent-level categories (e.g., "BAÑOS", "MOBILIARIO", "PISOS - GUARDAESCOBAS", "REVESTIMIENTOS") from the import that don't have direct HS code mappings. These are treated as unmatched and can be handled via `--use-ai` or manual assignment later.
- The `hs_codes` section in `seed_mappings.json` maps HS code strings (e.g., "7324.90") to UUIDs. The `suggest_hs_code()` method returns codes in `XXXX.XX.XX` format, so the script should truncate to `XXXX.XX` (7 chars) when matching against seeded codes.
- `scripts/output/` is already in `.gitignore`, so `hs_assignment_results.json` won't be committed.
- No frontend changes are needed for this issue — it's a backend-only script.
